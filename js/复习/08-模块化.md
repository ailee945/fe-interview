# 模块化

[toc]

## webpack 中 loader 和 plugin 的区别？

### loader

- 在打包前或期间调用
- 根据不同匹配条件处理资源
- 调用顺序与书写顺序相反
- 写在前面的接收写在后面的返回值作为输入值

### plugin

- 基于 `Tapable` 实现
- 事件触发调用，监听 `webpack` 广播的事件
- 不同生命周期改变输出结果

## 如何自定义一个 webpack 插件？

- 声明一个自定义命名的类或函数
- 在原型中新增 apply 方法
- 声明由 Compiler 模块暴露的生命周期函数
- 使用 webpack 提供的 API 或 自行处理内部实例的数据
- 处理完成后，调用 webpack 提供的回调函数

实现一个 MyPlugin，获取指定图片，新增静态资源到本地

```js
class MyPlugin { // 声明类
 apply(compiler) { // 新增 apply 方法
  // 声明生命周期函数
  compiler.hooks.additionalAssets.tapAsync('MyPlugin', (compilation, callback) => {
   download('https://img.shields.io/npm/v/webpack.svg', res => {
    if (res.status === 200) {
     // 调用 API
     compilation.assets['webpack-version.svg'] = toAsset(res)
     // 异步处理后，调用回调函数
     callback()
    } else {
     callback(new Error('[webpack-example-plugin] Unable to download the image'))
    }
   })
  })
 }
}
```

## 对比 import、import() 和 requrie

|对比项目|import|import()|require|
|:---:|:---:|:---:|:---:|
|规范|ES6Module|ES6Module|CommonJS|
|执行阶段|静态|编译阶段|动态 执行阶段|动态 执行阶段|
|顺序|置顶最先|异步|同步|
|缓存|√|√|√|
|默认导出|default|default|直接赋值|
|导入赋值|解构赋值，传递引用|在then方法中解构赋值，属性值是仅可读，不可修改|基础类型 赋值，引用类型 浅拷贝|

## 如何实现一个深拷贝，要点是什么？

手写函数
