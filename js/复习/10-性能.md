# 性能

[toc]

## JavaScript 垃圾回收机制

### 引用计数法

清除没有引用指向的数据

### 标记清除法

标记根元素可达数据，清除不可达数据。可处理循环引用。现代浏览器广泛使用

- 从根出发：包括 全局变量、本地函数的局部变量、参数、调用链上其它函数的局部变量和函数等
- 标记相连的对象为可达和访问过
- 直到引用链上没有未访问过的对象为止
- 删除没有被标记过，即不可达对象

### 标记清除法的优化

标记清除存在 内存不连续，回收效率低，偶尔卡顿 的缺点

- 只在CPU空闲时进行
- 分代回收：
  - 新生代：存活时间短，新生或经过一次垃圾回收的对象
    - 复制：复制 From 的可达对象 到 To 空间，释放 不可达对象
    - 晋升：复制时，To 空间使用超过 25%，晋升到 老生代
    - 交换：交换 From 和 To 空间
  - 老生代：存活时间长，经过一次被晋升或多次垃圾回收的对象
    - 标记清除
    - 标记整理：清除阶段先整理，将可达对象连续放置一起，再释放之外内存
    增量标记：用增量标记代替全暂停，在回收间歇执行应用逻辑，避免卡顿

## 详解标记整理算法

- 标记完成
- 存活对象向内存空间一端移动
- 移动完成，清理掉边界外的所有内存

## 前端常见的内存溢出途径，如何避免？

### 途径

1. 全局变量

由于JavaScript对未声明变量的处理方式是在全局对象上创建该变量的引用。如果在浏览器中，全局对象就是window对象。

变量在窗口关闭或重新刷新页面之前都不会被释放，如果未声明的变量缓存大量的数据，就会导致内存泄露。

2. 循环引用

在js的内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。

3. 闭包

闭包会造成对象引用的生命周期脱离当前函数的上下文，如果闭包如果使用不当，可以导致环形引用（circular reference），类似于死锁，只能避免，无法发生之后解决，即使有垃圾回收也还是会内存泄露

4. 延时器/定时器

setInterval/setTimeout 中的 this 指向的是window对象，所以内部定义的变量也挂载到了全局；if 内引用了 someResource 变量，如果没有清除 setInterval/setTimeout 的话someResource 也得不到释放；同理其实 setTimeout 也一样。所以我们用完需要记得去 clearInterval/clearTimeout。

5. DOM引起的内存泄露

未清除DOM引用; DOM对象添加的属性是一个对象的引用; 给DOM对象绑定事件

6. 其他原因

console.log打印的对象不能被垃圾回收，可能会导致内存泄露。

### 避免

变量导致的内存泄露，将变量清除 a = null 即可。

事件监听导致的内存泄露，监听后移除即可。